#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include "FreeRTOS.h"
#include "FreeRTOS_CLI.h"
#include "queue.h"
#include "task.h"

#include "tasks.h"
#include "uart.h"

#define MAX_INPUT_LENGTH    50
#define MAX_OUTPUT_LENGTH   100

extern QueueHandle_t UartQueue;

void vCommandConsoleTask( void *pvParameters )
{

BaseType_t xMoreDataToFollow;
RxStruct ReceivedCommand;
	char pcWriteBuffer[MAX_OUTPUT_LENGTH];

    for( ;; )
    {
        /* This implementation reads a single character at a time.  Wait in the
        Blocked state until a character is received. */
       // FreeRTOS_read( xConsole, &cRxedChar, sizeof( cRxedChar ) );

        if( xQueueReceive( UartQueue, &ReceivedCommand,0 ) == pdTRUE )
        {

            do
            {
                /* Send the command string to the command interpreter.  Any
                output generated by the command interpreter will be placed in the 
                pcOutputString buffer. */
                xMoreDataToFollow = FreeRTOS_CLIProcessCommand
                              (     
                                  (const char*)ReceivedCommand.tx_buff,   /* The command string.*/
                                  pcWriteBuffer,  /* The output buffer. */
                                  MAX_OUTPUT_LENGTH/* The size of the output buffer. */
                              );

                /* Write the output generated by the command interpreter to the 
                console. */
               // FreeRTOS_write( xConsole, pcOutputString, strlen( pcOutputString ) );

            } while( xMoreDataToFollow != pdFALSE );

            /* All the strings generated by the input command have been sent.
            Processing of the command is complete.  Clear the input string ready 
            to receive the next command. */
						
            memset( ReceivedCommand.tx_buff, 0x00, MAX_RxStruct_BUFF_SIZE );
						vTaskSuspend(  NULL );
        }
      
    }
}        
		